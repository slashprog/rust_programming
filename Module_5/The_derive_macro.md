# The `#[derive(...)]` Attribute in Rust

The `#[derive(...)]` attribute is one of Rust's most powerful features for automatic trait implementation. It tells the compiler to automatically generate implementations for specified traits based on the structure of your type.

## 1. **What Does `#[derive(...)]` Do?**

```rust
// Without derive - you'd have to implement manually
#[derive(Debug, Clone, PartialEq)]
struct User {
    id: u32,
    name: String,
    email: String,
}

// What derive generates automatically:
// - Debug: Enables {:?} formatting
// - Clone: Enables .clone() method
// - PartialEq: Enables == and != comparisons

fn main() {
    let user1 = User {
        id: 1,
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
    };
    
    let user2 = user1.clone();  // From Clone
    
    println!("{:?}", user2);      // From Debug
    println!("{}", user1 == user2); // From PartialEq
}
```

## 2. **Commonly Used Derivable Traits**

```rust
// Debug - Enables formatting with {:?}
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

// Clone - Enables .clone() for creating copies
#[derive(Clone)]
struct Config {
    timeout: u32,
    retries: u8,
}

// Copy - Enables implicit copying (only for simple types)
#[derive(Copy, Clone)]
struct Color {
    r: u8,
    g: u8,
    b: u8,
}

// PartialEq - Enables == and !=
#[derive(PartialEq)]
struct Version {
    major: u32,
    minor: u32,
}

// Eq - Enables strict equality (requires PartialEq)
#[derive(PartialEq, Eq)]
struct StatusCode(u16);

// PartialOrd - Enables <, >, <=, >=
#[derive(PartialEq, PartialOrd)]
struct Temperature(f32);

// Ord - Enables total ordering (requires Eq, PartialOrd)
#[derive(PartialEq, Eq, PartialOrd, Ord)]
struct Priority(u8);

// Hash - Enables use in HashMap/HashSet keys
#[derive(Hash)]
struct SessionId(u64);

// Default - Enables default() method
#[derive(Default)]
struct AppConfig {
    host: String,
    port: u16,
    debug: bool,
}

fn main() {
    // Debug
    let p = Point { x: 10, y: 20 };
    println!("{:?}", p);  // Point { x: 10, y: 20 }
    
    // Clone
    let cfg = Config { timeout: 30, retries: 3 };
    let cfg2 = cfg.clone();
    
    // Copy
    let c1 = Color { r: 255, g: 0, b: 0 };
    let c2 = c1;  // c1 still usable (Copy)
    
    // Default
    let app = AppConfig::default();  // host: "", port: 0, debug: false
    
    // Comparisons
    let v1 = Version { major: 1, minor: 0 };
    let v2 = Version { major: 1, minor: 2 };
    println!("{}", v1 < v2);  // true
    
    // Ordering
    let mut priorities = vec![Priority(3), Priority(1), Priority(2)];
    priorities.sort();  // Works because of Ord
}
```

## 3. **Custom Derive Macros (Serde Example)**

```rust
use serde::{Serialize, Deserialize};

// Serde's derive macros generate serialization/deserialization code
#[derive(Serialize, Deserialize, Debug)]
struct Person {
    name: String,
    age: u8,
    email: String,
    #[serde(default)]  // Optional field with default
    phone: Option<String>,
    #[serde(rename = "employee_id")]  // Rename in serialized format
    id: u32,
}

fn main() -> Result<(), serde_json::Error> {
    let person = Person {
        name: "Alice".to_string(),
        age: 30,
        email: "alice@example.com".to_string(),
        phone: None,
        id: 12345,
    };
    
    // Serialize to JSON (generated by Serialize derive)
    let json = serde_json::to_string_pretty(&person)?;
    println!("Serialized: {}", json);
    
    // Deserialize from JSON (generated by Deserialize derive)
    let deserialized: Person = serde_json::from_str(&json)?;
    println!("Deserialized: {:?}", deserialized);
    
    Ok(())
}
```

## 4. **What Derive Actually Generates**

```rust
// Your code:
#[derive(Debug, Clone, PartialEq)]
struct User {
    id: u32,
    name: String,
}

// Roughly what the compiler generates:
impl std::fmt::Debug for User {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("User")
            .field("id", &self.id)
            .field("name", &self.name)
            .finish()
    }
}

impl Clone for User {
    fn clone(&self) -> Self {
        User {
            id: self.id.clone(),      // u32 is Copy, so just self.id
            name: self.name.clone(),  // String requires explicit clone
        }
    }
}

impl PartialEq for User {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id && self.name == other.name
    }
}

// You'd have to write all this manually without derive!
```

## 5. **When Derive Doesn't Work**

```rust
// Derive fails for types with non-derivable fields
#[derive(Clone)]  // Works - all fields implement Clone
struct Valid1 {
    data: String,  // String implements Clone
    num: i32,       // i32 implements Clone
}

#[derive(Clone)]  // ERROR: *const i32 doesn't implement Clone
struct Invalid1 {
    ptr: *const i32,  // Raw pointer - no Clone!
}

#[derive(Debug)]  // ERROR: Secret doesn't implement Debug
struct Invalid2 {
    secret: Secret,  // Custom type without Debug
}

struct Secret {
    value: i32,
}

// Solution: Implement manually
impl Debug for Invalid2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("Invalid2")
            .field("secret", &"[redacted]")
            .finish()
    }
}
```

## 6. **Combining Multiple Derives**

```rust
// Order usually doesn't matter, but some traits depend on others
#[derive(
    Debug,           // For printing
    Clone,           // For duplication
    Copy,            // For implicit copy (requires Clone)
    PartialEq,       // For equality
    Eq,              // For strict equality (requires PartialEq)
    Hash,            // For hashing (requires Eq)
    Default          // For default values
)]
struct UserId(u64);

// Common combinations
#[derive(Debug, Clone, PartialEq)]  // For data containers
struct DataPoint {
    x: f64,
    y: f64,
}

#[derive(Debug, Clone, Copy, PartialEq)]  // For small values
struct Vector3 {
    x: f32,
    y: f32,
    z: f32,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]  // For map keys
struct SessionToken(String);

#[derive(Debug, Clone, PartialEq, Default)]  // For configuration
struct Settings {
    theme: String,
    font_size: u32,
    fullscreen: bool,
}
```

## 7. **Custom Derive Macros**

```rust
// You can create your own derive macros
// In a separate crate (my_derive/Cargo.toml):
// [lib]
// proc-macro = true

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);
    let name = &ast.ident;
    
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello from {}", stringify!(#name));
            }
        }
    };
    
    gen.into()
}

// Usage:
use my_derive::HelloMacro;

trait HelloMacro {
    fn hello_macro();
}

#[derive(HelloMacro)]
struct MyStruct;

fn main() {
    MyStruct::hello_macro();  // Prints: "Hello from MyStruct"
}
```

## 8. **Conditional Derive with Features**

```rust
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Clone, PartialEq)]
struct Config {
    timeout: u32,
    retries: u8,
}

// With feature flags:
// cargo build --features "serde debug"
// - Derives Serialize, Deserialize, Debug
// cargo build --no-default-features
// - Only derives Clone, PartialEq
```

## 9. **Performance Implications**

```rust
// Derive is zero-cost - generated code is as efficient as manual impl

// These two are equivalent in performance:
#[derive(Clone)]
struct Data1 {
    numbers: Vec<i32>,
    name: String,
}

struct Data2 {
    numbers: Vec<i32>,
    name: String,
}

impl Clone for Data2 {
    fn clone(&self) -> Self {
        Data2 {
            numbers: self.numbers.clone(),  // O(n) operation
            name: self.name.clone(),         // O(n) operation
        }
    }
}
```

## 10. **Common Patterns and Best Practices**

```rust
// 1. Always derive Debug for debugging
#[derive(Debug)]
struct MyType;

// 2. Derive Clone when you need duplication
#[derive(Clone)]
struct Cacheable(String);

// 3. Derive Copy for small, trivial types
#[derive(Copy, Clone)]
struct Point(i32, i32);

// 4. Derive PartialEq for comparability
#[derive(PartialEq)]
struct Version(u32, u32);

// 5. Derive Eq when you need total equality
#[derive(PartialEq, Eq, Hash)]
struct Id(u64);

// 6. Derive Default for configuration types
#[derive(Default)]
struct Config {
    host: String,
    port: u16,
}

// 7. Use serde for serialization
#[derive(serde::Serialize, serde::Deserialize)]
struct ApiResponse {
    status: u16,
    data: Vec<u8>,
}
```

## Quick Reference Table

| Trait | Purpose | Requirements |
|-------|---------|--------------|
| `Debug` | Formatted output `{:?}` | None |
| `Clone` | Explicit duplication `.clone()` | All fields implement `Clone` |
| `Copy` | Implicit copying (stack-only) | All fields implement `Copy` |
| `PartialEq` | Equality `==`, `!=` | All fields implement `PartialEq` |
| `Eq` | Strict equality (no floats) | Requires `PartialEq` |
| `PartialOrd` | Partial ordering `<`, `>`, etc. | All fields implement `PartialOrd` |
| `Ord` | Total ordering | Requires `Eq`, `PartialOrd` |
| `Hash` | Hashing for collections | All fields implement `Hash` |
| `Default` | Default value `default()` | All fields implement `Default` |

## Summary

`#[derive(...)]` is Rust's way of saying "compiler, please write the boilerplate code for these traits for me." It:
- **Saves time** - No manual implementation of common traits
- **Reduces errors** - Generated code is guaranteed correct
- **Improves readability** - Declarative instead of imperative
- **Zero-cost** - Generated code is as efficient as hand-written
- **Composable** - Works with custom derive macros

The most common combination is `#[derive(Debug, Clone, PartialEq)]` for data structures that need printing, cloning, and comparison.